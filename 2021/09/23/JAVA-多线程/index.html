<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA," />










<meta name="description" content="多线程基础语法进程和线程 进程是一个程序的实例，当程序从磁盘被加载到内存中，就开启了一个进程 一个进程可以拥有多个线程，线程之间共享资源，进程是线程的容器 线程是调度的基本单位，进程是资源分配的基本单位 进程之间通信较为复杂，线程通信相对简单，因为共享内存 线程更轻量，其上下文切换成本更低  并发和并行GO语言之父Rob Pike　  并发是同一时间应对（deal with）多件事情的能力。 并行">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA 多线程">
<meta property="og:url" content="http://example.com/2021/09/23/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="LP&#39;s Blog">
<meta property="og:description" content="多线程基础语法进程和线程 进程是一个程序的实例，当程序从磁盘被加载到内存中，就开启了一个进程 一个进程可以拥有多个线程，线程之间共享资源，进程是线程的容器 线程是调度的基本单位，进程是资源分配的基本单位 进程之间通信较为复杂，线程通信相对简单，因为共享内存 线程更轻量，其上下文切换成本更低  并发和并行GO语言之父Rob Pike　  并发是同一时间应对（deal with）多件事情的能力。 并行">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212052270.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212103473.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212122933.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212222587.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310093448604.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310185714858.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310190325275.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220311165044043.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220311165313004.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313145757527.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313151449466.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313181143460.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313193847653.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313200543328.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314095436880.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314095627142.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314100656134.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314102851826.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314144947794.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314132511869.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314195158551.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314195540213.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314200128763.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314205504786.png">
<meta property="og:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/v2-c7246e74cc64c786360ae12e266e0362_r.jpg">
<meta property="article:published_time" content="2021-09-23T15:51:44.000Z">
<meta property="article:modified_time" content="2022-08-04T16:52:47.385Z">
<meta property="article:author" content="Pan Li">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212052270.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2021/09/23/JAVA-多线程/"/>





  <title>JAVA 多线程 | LP's Blog</title>
  








<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LP's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">懂的越多方知懂的越少</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/23/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LP's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA 多线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-23T23:51:44+08:00">
                2021-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  39 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li>进程是一个程序的实例，当程序从磁盘被加载到内存中，就开启了一个进程</li>
<li>一个进程可以拥有多个线程，线程之间共享资源，进程是线程的容器</li>
<li>线程是调度的基本单位，进程是资源分配的基本单位</li>
<li>进程之间通信较为复杂，线程通信相对简单，因为共享内存</li>
<li>线程更轻量，其上下文切换成本更低</li>
</ul>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>GO语言之父Rob Pike　</p>
<ul>
<li>并发是同一时间应对（deal with）多件事情的能力。</li>
<li>并行是统一时间动手做（doing）多件事情的能力。</li>
</ul>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>需要等待结果返回才能继续运行，就是同步</p>
<p>不需要等待结果返回，就能继续运行，就是异步</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>java线程调用start之后，究竟是否start后被不被执行，取决于操作系统调度</p>
<p>调用 Thread.sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p>
<p>调用 Thread.yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程,当然哪个具体哪个线程执行取决于操作系统调度器</p>
<p>调用 t.join 等待线程结束</p>
<h4 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h4><p>打断阻塞线程 会重置打断标记IsInterrupted 即&#x3D;false     ,打断正在运行线程则会设置&#x3D;true</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<ul>
<li>垃圾回收器就是守护线程</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>操作系统线程状态：初始，运行，阻塞，就绪，终止</p>
<p>JAVA中操作系统状态 ：</p>
<ul>
<li>NEW 线程刚被创建，但是还没有调用 start() 方法</li>
<li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的<br>  【就绪状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为<br>  是可运行）</li>
<li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节<br>  详述</li>
<li>TERMINATED 当线程代码运行结束</li>
</ul>
<p>本章的重点在于掌握</p>
<ul>
<li>线程重要 api，如 start，run，sleep，join，interrupt 等</li>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：join</li>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 两种创建方式 的源码</li>
</ul>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul>
<li>一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源</li>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
<li>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></li>
</ul>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><strong>开闭原则中的闭合原则，不想往外暴露的，就设置成final，增加类的	性</strong></p>
<blockquote>
<p>String 如果不设计成Final ，那么其子类可能覆盖掉String类中的一些行为，导致线程不安全的发生</p>
</blockquote>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><ul>
<li>锁在方法上 等于锁this对象，锁在静态方法上，等于锁class对象</li>
</ul>
<h3 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h3><ul>
<li><p>String</p>
</li>
<li><p>Integer</p>
</li>
<li><p>StringBuffer</p>
</li>
<li><p>Random</p>
</li>
<li><p>java.util.concurrent 包下的类</p>
<p>  这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。</p>
</li>
</ul>
<h3 id="怎么样会引发线程不安全？"><a href="#怎么样会引发线程不安全？" class="headerlink" title="怎么样会引发线程不安全？"></a>怎么样会引发线程不安全？</h3><p>对共享变量有读写操作</p>
<h3 id="对象头-，锁到底在哪里？"><a href="#对象头-，锁到底在哪里？" class="headerlink" title="对象头 ，锁到底在哪里？"></a>对象头 ，锁到底在哪里？</h3><p>对象&#x3D;对象头+实例对象+填充</p>
<p>对象头&#x3D;Mark word + Class word（类对象）</p>
<p>Mark word 里包含 hashcode、age、各种锁和加锁状态</p>
<h3 id="Monitor（监视器-x2F-管程）"><a href="#Monitor（监视器-x2F-管程）" class="headerlink" title="Monitor（监视器&#x2F;管程）"></a>Monitor（监视器&#x2F;管程）</h3><p>对象&#x3D;Mark Word+ class word(指向方法区的指针）+object body</p>
<p>普通对象</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212052270.png" alt="image-20220309212052270"></p>
<p>数组对象</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212103473.png" alt="image-20220309212103473"></p>
<p>Mark Word结构</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212122933.png" alt="image-20220309212122933"></p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220309212222587.png" alt="image-20220309212222587"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>一个对象的多线程访问时间是错开的，那么可以使用轻量级锁来优化</p>
<blockquote>
<p>栈帧里维护一个lock record（锁记录&#x3D;锁记录地址+00  和 对象地址）,使用CAS机制将锁记录地址与对象头互换  </p>
<p>CAS失败：</p>
<p>如果发现lock record是当前线程 执行锁重入</p>
<p>否则【锁膨胀】 升级重量级锁  对象头变为Monitor指针 owner指向被占用的线程 当前线程进入entryList</p>
</blockquote>
<h3 id="重量级锁竞争：锁自旋"><a href="#重量级锁竞争：锁自旋" class="headerlink" title="重量级锁竞争：锁自旋"></a>重量级锁竞争：锁自旋</h3><p>当对象头Markword是重量级锁指针时，进行几轮空转</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>【偏向锁】使用偏向锁在同一线程访问时就不必再进行CAS</p>
<p>【撤销】:</p>
<ol>
<li><p>对象调用了hashcode</p>
</li>
<li><p>当有其他线程使用偏向锁的时候，会将偏向锁升级为轻量锁，并且释放后锁状态改为不可偏向锁。</p>
</li>
<li><p>调用wait notify ，因为只有重量级锁才能实现</p>
</li>
</ol>
<p>【批量重偏向】：</p>
<p>当撤销偏向锁过多超过20次，JVM就不信任原来的线程，因此整个类的所有对象就可以进行重偏向，可以对锁进行重偏向</p>
<p>【批量撤销】</p>
<p>如果撤销超过40次，jvm会觉得就TM不该偏向，于是整个类的所有对象都会变为不可偏向，新建的对象也是不可偏向</p>
<p>【锁消除】</p>
<p>JIT即使编译器，对JAVA字节码进行进一步优化，发现局部变量不会逃离方法的作用范围，即局部变量不可能被共享，将会优化对局部变量的加锁代码。</p>
<h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310093448604.png" alt="image-20220310093448604"></p>
<ul>
<li>owner发现条件不满足，调用wait，进入WaitSet，变为WAITING状态</li>
<li>BLOCKED 的线程 是获得不了锁 在等待锁，WAITING线程是 获得了锁，又主动释放掉了，进入等待，他们都不会占用CPU时间</li>
<li>notify唤醒waiting线程后会重新进入entryList竞争</li>
</ul>
<h3 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep 和 wait 的区别"></a>sleep 和 wait 的区别</h3><ul>
<li>sleep是Thread类的方法，wait是Object的方法</li>
<li>sleep不需要获得对象锁，wait需要获得对象锁</li>
<li>sleep不会释放锁，wait会释放锁</li>
<li>sleep(long) wait(long)后线程状态都是TIMED_WAITING  wait()后线程状态是WAITING</li>
<li>wait() 与join()的区别: join是一个线程等待另一个线程的结束 但join的实现其实用的也是wait</li>
</ul>
<h3 id="同步模式：-保护性暂停模式"><a href="#同步模式：-保护性暂停模式" class="headerlink" title="同步模式： 保护性暂停模式"></a>同步模式： 保护性暂停模式</h3><p>一个JAVA线程需要等待另一个JAVA线程的运行结果，即Guarded Suspension</p>
<p>异步模式: 生产者消费者模式</p>
<h3 id="park和Notify的区别"><a href="#park和Notify的区别" class="headerlink" title="park和Notify的区别"></a>park和Notify的区别</h3><ul>
<li><p>wait notify  必须配合Monitor使用，而park Unpark不必</p>
</li>
<li><p>park和unpark以线程为单位唤醒，notify随机</p>
<p>  park原理，每个线程都有一个 Parker对象，由三部分组成_mutex, _cond , _counter(备用干粮)</p>
</li>
</ul>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310185714858.png" alt="image-20220310185714858"></p>
<h3 id="线程之间的状态转换"><a href="#线程之间的状态转换" class="headerlink" title="线程之间的状态转换"></a>线程之间的状态转换</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220310190325275.png" alt="image-20220310190325275"></p>
<ol>
<li>调用start()</li>
<li>t线程用synchronized(obj) 获取对象锁后<ul>
<li>调用obj.wait()方法 ：runnable-&gt;waitting</li>
<li>其他线程调用obj.notify() obj.notify() t.interrupt()后 waiting-&gt;blocked 从 waitSet 进入 EntryList</li>
</ul>
</li>
<li>当前线程调用t.join()方法 当前线程从runnable 到waiting</li>
<li>LockSupport.park() LockSupport.unpark(t)</li>
</ol>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>一个进程想加到100 一个进程减道0  俩特么怼到天亮永远也停不了</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低，永远得不到CPU调度执行</p>
<h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul>
<li>互斥条件：一个资源只能被一个进程占用</li>
<li>请求和保持条件：一个资源请求资源而阻塞时， 对已经获得的资源不释放</li>
<li>不可剥夺条件：进程已经获得的资源不会被其他进程剥夺</li>
<li>循环等待条件：若干进程形成了一种首尾相接的资源等待关系</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li>可打断：等待锁.lockInterruptibly()时可以被Interrupted 属于被动解决死锁</li>
<li>可以设置超时时间：主动解决死锁 </li>
<li>可以设置公平锁：先进先出，防止饥饿，实际没有必要，trylock() 就好，公平锁会降低并发度</li>
<li>支持多个条件变量 condition.await() condition.singal() 而synchronized锁的对象只能调一个wait()</li>
</ul>
<h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><ul>
<li><p>互斥 使用Synchronized  或 Lock 达到共享资源互斥效果</p>
</li>
<li><p>同步 使用wait&#x2F;notify 或 condition. await&#x2F;signal 或 LockSupport.park unpark达到 线程间通信的效果</p>
</li>
<li><p>wait notify 对标的是锁对象</p>
</li>
<li><p>await signal 对标的是ReentrantLock的条件变量Condition</p>
</li>
<li><p>park unpark 对标的是线程</p>
</li>
<li><p>monitor原理(waitSet EntryList Owner) 又JVM里的C++源码实现 ReentrantLock在JAVA级别实现了Monitor</p>
</li>
<li><p>synchrnized原理（对象头、CAS、偏向锁、轻量级锁、重量级锁、锁膨胀、锁撤销、锁自旋、锁消除）</p>
</li>
<li><p>wait&#x2F;notify 原理 （waitSet等待)</p>
</li>
<li><p>park unpark原理（_cond _mutx _counter)</p>
</li>
<li><p>同步模式 保护性暂停模式（线程1想获得线程2执行后的结果）</p>
</li>
<li><p>异步模式 生产者消费者</p>
</li>
<li><p>同步模式 顺序控制 三个线程输出abcabcabc</p>
</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>java内存模型JMM，从JAVA层面定义了<strong>主存（共享数据）、工作内存（线程私有数据）</strong>的概念，看似就两个东西，但是底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等一大堆无法兼顾的问题，主要让JAVA程序员不用考虑复杂的内存管理</p>
<p>JMM体现在以下几个方面：</p>
<ul>
<li>原子性-保证指令不会受到线程上下文切换的影响 synchronized  </li>
<li>可见性-保证指令不会受到CPU缓存的影响 <ul>
<li>推荐：volatile 避免线程从工作缓存中查找变量的值，必须到主存中去操作，通常用在多个线程读，一个线程写的情况中</li>
<li>synchronized 也能实现，JMM规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li>
</ul>
</li>
<li>有序性-保证指令不会受到CPU指令并行优化的影响 加volatile 禁止之前代码重排序</li>
</ul>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220311165044043.png" alt="image-20220311165044043"></p>
<p>每条指令执行过程分为：</p>
<ul>
<li>取指令   instruction fetch IF</li>
<li>指令译码 instruction decode ID</li>
<li>执行指令 execute EX</li>
<li>内存访问 memory access MEM</li>
<li>数据写回 register write back WB</li>
</ul>
<p>现代CPU支持多指令级流水线，能够并行执行指令五个过程的称为五级指令流水线<img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220311165313004.png" alt="image-20220311165313004"></p>
<p> 为了减少指令并行化导致的阻塞，JIT（Just-In-Time） J即时编译器会进行指令重排序提高吞吐量</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>底层实现原理是内存屏障 Memory Barrier (Memory Fence)</p>
<ul>
<li>对volatile的写指令会加入写屏障</li>
<li>对volatile的<strong>读指令前</strong>会加入读屏障</li>
</ul>
<p>写屏障（sfence）：</p>
<ul>
<li>该屏障之前，所有对共享变量的改动，都同步到主存当中。 </li>
<li>不会对写屏障之前的代码进行指令重排</li>
</ul>
<p>读屏障（lfence) : 保证该屏障之后，对共享变量的读取，加载的是主存中的最新数据</p>
<p>读写屏障不能保证原子性，只能保证有序性（禁止重排）和可见性（读主存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    num=<span class="number">2</span>;</span><br><span class="line">    ready=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//写屏障   之前数据全部写入主存  之前的代码不允许指令重排</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    <span class="comment">//读屏障 之后的数据全部从主存中读 之后的代码不允许指令重拍</span></span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1=num+num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dcl-double-check-lock问题"><a href="#dcl-double-check-lock问题" class="headerlink" title="dcl double check lock问题"></a>dcl double check lock问题</h3><p>new Singleton();过程分为四步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17: new #3 // 堆上创建对象 引用入栈</span><br><span class="line">20: dup // 获得引用</span><br><span class="line">21: invokespecial #4 // 调用构造方法</span><br><span class="line">24: putstatic #2 // 引用复制给静态变量</span><br></pre></td></tr></table></figure>

<p>synchronized 里面的代码会发生指令重排序 可能会先执行24 再执行21，当24和21期间其他线程有可能会访问，即会反回一个未调用构造方法的静态变量	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">        <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式问题"><a href="#单例模式问题" class="headerlink" title="单例模式问题"></a>单例模式问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final : 防止子类覆盖方法破坏单例</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例： 增加readResolve()方法 反序列化过程中一旦发现readResolve会将该方法返回的对象作为返回对象 而不是把反序列化字节码生成的对象当成反序列化结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例? ：别的类就能无限创建对象了，不能防止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全? : 静态成员变量的初始化操作在类加载阶段完成，JVM保证线程安全性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由：</span></span><br><span class="line">    <span class="comment">//  可以实现懒汉式，当前是饿汉式</span></span><br><span class="line">    <span class="comment">//  对创建的单例对象有更多的控制</span></span><br><span class="line">    <span class="comment">//  提供泛型支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的  ：枚举类的实例实际上就是这个类的静态成员变量</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题 ： 没有 静态成员变量</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例： 不能，枚举类型不能通过new Instance创建</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例：  不会被破坏</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式： 饿汉</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做 ： 写构造方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点: 性能比较差 每次都得枷锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DCL实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ? ：指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义 ： 提高效率减少加锁次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗 ：线程原子性</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式:懒汉 类加载本身是懒惰 类只有第一次被用到时才会出发类加载操作 真的懒 机器懒 人也懒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题 JVM保证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>可见性-由JVM缓存引起</li>
<li>有序性-由JVM指令重排序引起</li>
<li>原理方面：cpu指令并行，volatile写屏障读屏障</li>
<li>模式方面： 两阶段终止 用volatile实现，同步模式Balking ：实现单例模式 监控线程</li>
</ul>
<h1 id="无锁并发-乐观锁方式（实现非阻塞并发访问）"><a href="#无锁并发-乐观锁方式（实现非阻塞并发访问）" class="headerlink" title="无锁并发 乐观锁方式（实现非阻塞并发访问）"></a>无锁并发 乐观锁方式（实现非阻塞并发访问）</h1><h3 id="CAS工作方式："><a href="#CAS工作方式：" class="headerlink" title="CAS工作方式："></a>CAS工作方式：</h3><p>compareAndSet()方法 简称CAS（也有Compare and swap的说法）在CPU底层实现了原子性 底层使用lock cmpxchg指令(X86) </p>
<h3 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证变量的可见性，需要使用volatile修饰</p>
<p>CAS必须借助volatile才能读到共享变量的最新值来实现【比较并交换】效果</p>
<h3 id="无锁效率高不高？"><a href="#无锁效率高不高？" class="headerlink" title="无锁效率高不高？"></a>无锁效率高不高？</h3><ul>
<li>无锁情况下，即使重试失败，线程依然高速运行，没有停歇，而synchronized会让线程从RUNNABLE进入BLOCKING，进入阻塞，发生上下文切换</li>
<li>无锁情况下，线程要保持运行，需要CPU支持，没有CPU时间仍然会导致上下文切换，多核才能发挥优势，最好线程数不要超过CPU的核数</li>
</ul>
<h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><ul>
<li>CAS基于乐观锁的思想，不怕别的线程来修改共享变量，就算改了也没关系，改了我就重试呗</li>
<li>synchronized基于悲观锁思想 得防止其他线程来修改共享变量，我上了锁你们都别想改</li>
<li>CAS体现的是无锁并发、无阻塞并发：因为无阻塞，效率提升，但因为需要重试，效率又受到影响。</li>
</ul>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p> A-&gt;B-&gt;A 然后主线程A-&gt;B依然成功，主线程无法感知到A进行了两次修改</p>
<p>只要有线程动过了共享变量，那么CAS就应该算作失败，这时候需要加一个版本号 AtomicStampReference</p>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>CAS的 compareAndSet比较的就是引用地址！！因此要对数组内某个元素做修改，看不到</p>
<h3 id="LongAdder-原子累加器"><a href="#LongAdder-原子累加器" class="headerlink" title="LongAdder 原子累加器"></a>LongAdder 原子累加器</h3><p>当有竞争时，累加器里面的While会循环多次，而Longadder会设置多个累加单元，最后进行汇总，减少了CAS重试次数</p>
<p>transient序列化时隐藏字段</p>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><p>提供了非常底层的，操作内存、线程的方法，unsafe不能直接调用，只能通过反射获得</p>
<p>叫unsafe是因为他比较底层，别乱用，但他是线程安全的，很多Locksupport、原子对象都使用了Unsafe实现功能</p>
<p>JDK的原子整数类实际上就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="built_in">this</span>.value;</span><br><span class="line">        <span class="type">int</span> next=<span class="built_in">this</span>.value-amount;</span><br><span class="line">        <span class="keyword">if</span>(unsafe.compareAnsSwapInt(<span class="built_in">this</span>,valueOffset,prev,next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>CAS和volatile</li>
<li>原子整数、引用、数组，字段更新器，字段累加器</li>
<li>Unsafe类</li>
</ul>
<h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>String类如何保证字符串不可变的</p>
<ul>
<li><p>final类 防止被继承</p>
</li>
<li><p>保护性拷贝【defensive copy】 构造新String对象时会调用Arrays.copy()生成新的数组作为value引用，避免共享</p>
</li>
<li><p>但是这样的话就会导致 创建的对象个数很多 因此JOF23种设计模式【享元模式】 需要重用数量有限的同一类对象时使</p>
<blockquote>
<p>JDK中享元模式的体现：</p>
<ul>
<li><p>包装类</p>
<p>  例如Long中的valueOf会缓存-128~127之间的对象，在这个范围内重用对象，大于这个范围才会创建新的Long对象</p>
</li>
<li><p>String字符串常量池</p>
</li>
<li><p>BigDecimal BigInteger</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="final变量原理"><a href="#final变量原理" class="headerlink" title="final变量原理"></a>final变量原理</h3><ul>
<li>final声明的变量的下面会加写屏障</li>
<li>静态常量在编译时就已经写死了 不会发生任何变化 编译器直接引用</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p>高并发下，为每个用户创建一个线程对内存占用相当大，线程太多CPU忙不过来，上下文切换频繁影响性能，因此要充分利用已有线程的潜力</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313145757527.png" alt="image-20220313145757527"></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>用int高3为来表示线程池状态，低29位表示线程池数量</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高三位</th>
<th>接受新任务</th>
<th>处理阻塞任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接受新任务，但会处理阻塞队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全部执行完毕，活动线程数为0,即将状态</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>TERMINATED&gt;TIDYING&gt;STOP&gt;SHUTDOWN&gt;RUNNING(负数)</p>
<p>这些信息存在一个原子变量ctl中，将线程池状态数和线程数合二为一，只需要一次原子操作就可以进行赋值</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>构造方法</p>
<ul>
<li>核心线程数</li>
<li>最大线程数 （多出来救急线程，当线程满阻塞队列满，创建救急线程执行，来的早不如来得巧）</li>
<li>救急线程最大存活时间 （救急线程&#x3D;临时工，干完活一段时间没活干了，解雇掉，下次高峰期来了，再创建一个，核心线程永远保留在线程池中）</li>
<li>存活时间单位</li>
<li>线程工厂（给线程起名字）</li>
<li>策略方法（阻塞队列满时干啥）</li>
</ul>
<p>具体实现</p>
<ul>
<li>有界队列时才会创建救急线程</li>
<li>拒接策略<ul>
<li><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313151449466.png" alt="image-20220313151449466"></li>
<li>放弃本次任务</li>
<li>放弃队列中最早的任务，本任务取而代之</li>
<li>调用者执行本任务</li>
<li>抛出异常</li>
</ul>
</li>
</ul>
<h3 id="invokeAll和invokeAny"><a href="#invokeAll和invokeAny" class="headerlink" title="invokeAll和invokeAny"></a>invokeAll和invokeAny</h3><p>invokeALL是异步执行，所以返回future<T>对象</p>
<p>invokeAny是同步执行，返回object对象，且任意一个任务执行成功后，不再执行剩余的任务</p>
<h3 id="结束线程池"><a href="#结束线程池" class="headerlink" title="结束线程池"></a>结束线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//修改线程池状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//仅结束空闲线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试终结，没有运行的线程可以立刻终结，如果还有运行的线程也不会等</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//STOP  范湖在阻塞队列中的任务</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            </span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            <span class="comment">//打断所有线程</span></span><br><span class="line">            interruptWorkers();</span><br><span class="line">            <span class="comment">//获取剩余任务</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多少个线程合适"><a href="#创建多少个线程合适" class="headerlink" title="创建多少个线程合适"></a>创建多少个线程合适</h3><ul>
<li><p>线程数目过少不能充分利用系统资源</p>
</li>
<li><p>过大会导致更多的上下文切换</p>
</li>
<li><p>CPU密集型运算：线程个数&#x3D;CPU核心数+1，+1保证当前线程由于页缺失或其他原因导致的暂停，额外的线程能够顶上去，保证CPU时钟周期不被浪费</p>
</li>
<li><p>I&#x2F;O密集型运算：IO操作、远程RPC调用、操作数据库，CPU就闲下来了，可以利用多线程提高它的利用率，经验公式如下：<br>  $$<br>  线程数&#x3D;核数* 期望CPU利用率*总时间(CPU计算时间+等待时间)&#x2F;CPU总时间<br>  $$</p>
</li>
</ul>
<h3 id="tomcat线程池"><a href="#tomcat线程池" class="headerlink" title="tomcat线程池"></a>tomcat线程池</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313181143460.png" alt="image-20220313181143460"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<h3 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>t1.fork() 创建线程分治执行</p>
<p>t1.join() 等待返回结果</p>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>AbstractQueuedSynchronizer 是阻塞式锁和相关同步器工具的框架</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取<br>  锁和释放锁 <ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
</ul>
</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
<li>提供了基于 FIFO 的等待队列，acquire()调用锁被占用时等待，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
<li>tryAcquire\tryRelease\tryAcquireShared\tryAcquireShared用到的话必须重写</li>
</ul>
<h3 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313193847653.png" alt="image-20220313193847653"></p>
<ul>
<li><p>有一个实现了AQS的同步器sync(可以是公平的或分公平的)来管理加锁解锁	</p>
</li>
<li><p>当调用lock时，进入sync的lock方法，调用sync的cas方法，cas失败则调用同步器的acquire方法，acquire 会tryaquire一次，不成功后将Node加入Node队列，队列是单向链表（图错了），且有dummy节点，有first tail节点，再加入队列时还会再挣扎几次</p>
<p>  <img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220313200543328.png" alt="image-20220313200543328"></p>
</li>
<li><p>可重入原理，计数和比较线程</p>
</li>
<li><p>阻塞时可打断原理</p>
<ul>
<li>可打断模式，等待时被打断，直接抛出异常</li>
<li>不可打断模式下，在AQS队列里，即使被打断，仍然在队列里等待但要记录被打断过，等到获得锁时返回 等待锁过程中是否被打断过，如果被打断过，再次调用被打断</li>
<li>其实AQS里面，所谓的阻塞其实就是在doAcquire方法里Park住了，这时候其他线程（前驱结点）唤醒他，需要通过unpark来叫醒继续运行，此外unpark不会设置打断位，可以通过判断打断位看看在park过程中是否被interrupt过</li>
</ul>
</li>
<li><p>公平锁</p>
<ul>
<li>非公平锁模式，看到getstate&#x3D;0直接开抢</li>
<li>公平锁模式，看到getstate&#x3D;0，先看看队列里有没有线程还</li>
</ul>
</li>
<li><p>条件变量</p>
<ul>
<li>当调用await时，将当前线程包装成Node加入条件变量对应的阻塞队列中去，因为Park是基于线程调用的，所以必须得有线程的引用，park住然后唤醒下一个节点</li>
<li>signal方法 唤醒条件变量，先要检查唤醒线程是否为持有者，将条件变量 等待队列的第一个线程取出，让他重新加入锁的等待队列</li>
</ul>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>为了实现 读读并发，提升性能</p>
<p>该Lock里面有两个类 一个是readlock一个是writelock</p>
<p>注意事项</p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时不支持升级，即持有锁读锁的情况下获取写锁，会导致写锁永久等待</li>
<li>重入时支持降级，即持有写锁 情况下去获取读锁</li>
</ul>
<h3 id="读写锁实现缓存、缓存更新策略"><a href="#读写锁实现缓存、缓存更新策略" class="headerlink" title="读写锁实现缓存、缓存更新策略"></a>读写锁实现缓存、缓存更新策略</h3><p>更新时，是先清缓存还是想先更新数据库？</p>
<ul>
<li><p>先清缓存</p>
<p>  <img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314095436880.png" alt="image-20220314095436880"></p>
</li>
<li><p>先更数据库</p>
<p>  <img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314095627142.png" alt="image-20220314095627142"></p>
</li>
</ul>
<h3 id="读写锁设计原理"><a href="#读写锁设计原理" class="headerlink" title="读写锁设计原理"></a>读写锁设计原理</h3><ul>
<li>state高16位给读锁用，低16位给写锁用，0未加锁，1已枷锁，大于1锁重入</li>
</ul>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314100656134.png" alt="image-20220314100656134"></p>
<p>每个Node有waitStatus，等于-1表示有职责去唤醒后继节点，等于0没事，和AQS一样，因为本来就是基于AQS实现的嘛，</p>
<p>每一个Node还有自己的状态，shared 和 Ex</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314102851826.png" alt="image-20220314102851826"></p>
<p>读锁结束后State-1 减到0唤醒老二</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314144947794.png" alt="image-20220314144947794"></p>
<h3 id="stampedLock"><a href="#stampedLock" class="headerlink" title="stampedLock"></a>stampedLock</h3><p>因为AQS里面读写锁实现还是靠park，每次读都要靠AQS 修改状态，性能依然不够牛逼，比不上不加锁，stampedLock特点使用读锁写锁时都必须配合【戳】使用</p>
<p>通过先读 然后验证stamp</p>
<p>乐观读不支持条件变量，不支持可重入</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>acquire() 和 Release() 类似于PV操作</p>
<p>本质上也是利用AQS实现的同步器类，把信号量存在了state里，</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314132511869.png" alt="image-20220314132511869"></p>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>用来进行线程同步协作，等待所有线程完成倒计时</p>
<p>其中构造参数用来初始化等待计数值，await()用来等待计数归零，countDown()用来让减一</p>
<p>为什么不用join呢，因为如果是线程池来调度，线程不会销毁，join永远等不到，其次是只要其他线程得到我需要的结果就可以让计数减一，不一定非得执行完毕</p>
<h3 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h3><p>循环删栏，用来进行线程协作，等待线程满足某个计数。构造时设置【计数个数】，每个线程执行到某个需要【同步】的时刻调用await()方法进行等地啊，当等待的线程数满足【计数个数】时，继续执行，【人满发车】</p>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h1><p>线程安全集合主要分为三大类：</p>
<ul>
<li>遗留的线程安全几何：Hashtable,vector 都是synchronized实现并发度较低，效率不高</li>
<li>使用Collections装饰的线程安全集合，全TM都是synchronized了一个mutex,(mutal exclusive)，装模作样的</li>
<li>JUC下的线程安全集合类<ul>
<li>Blocking 典型案例 阻塞队列，大部分实现基于锁，并提供用来阻塞的方法</li>
<li>CopyOnWrite 修改时拷贝，避免读写时的线程安全问题，适合读多写少场景，修改开销较重</li>
<li>Concurrent<ul>
<li>内部很多操作用CAS优化，一般可以提供较高的吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如当使用迭代器遍历时，如果容器发生了修改，迭代器仍然可以继续遍历，但内容是旧的<ul>
<li>求大小弱一致性，size操作未必是100%准确？</li>
</ul>
</li>
<li>读取弱一致性</li>
<li>这里的弱一致性是fail-save安全失败模式的实现原理，获得原集合的一份拷贝，在拷贝而来的集合上进行遍历，原集合发生的改变时，不会抛出CME异常，对于非安全容器来讲，使用fail-fast机制，如果遍历时发生了修改，抛出ConcurrentModificationException，不再继续遍历</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>在每个链表头上加锁，锁粒度较小</p>
<p><code>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction）</code>如果缺少一个key,则计算生成一个value，然后将key value放入map </p>
<ul>
<li>JDK7 HashMap 扩容过程会引发并发死链，JDK8 虽然对扩容算法进行了调整，不再将元素加入链表头，而是保持与扩容前一样的顺序，但还会出现线程安全问题</li>
</ul>
<p>JDK8</p>
<ul>
<li>懒惰初始化，构造方法中仅计算table大小，第一次使用时才会真正创建table </li>
<li>寻找数组下标 不再是长度取余 而是 (n-1)&amp; h，数组长度-1 【与】spared(key.hashcode())</li>
<li>put流程<ol>
<li>判断参数是否为null</li>
<li>判断table是否为Null，为Null进行初始化，初始化过程使用CAS</li>
<li>如果无头节点，即无冲突，创建并添加链表头节点</li>
<li>如果有头节点.hash等于-1说明正在扩容，要帮忙扩容，真TM一点都不闲着</li>
<li>有头结点，且不在扩容，锁住头结点判断是链表还是红黑树，判断是否存在相同key，往里插入</li>
<li>判断链表长度是否大于树化阈值，转为红黑树 ，结束</li>
</ol>
</li>
<li>transfer流程（扩容）<ol>
<li>参数是tab和nexttab，如果nexttab为null创建一个大小为tab*2的Node数组</li>
<li>tab往nexttab搬迁工作，以一个一个链表为单位<ol>
<li>链表头为NULL，表示已经被处理，将链表头替换成ForwardingNode</li>
<li>链表头已经是ForwardingNode，处理下一个链表</li>
<li>否则锁住链表，进行搬运，内部还要考虑是普通节点、树节点的搬迁逻辑！</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h5><ul>
<li>维护一个segment数组，每个Segment对应一把锁，多个线程访问不同的Segment没有冲突，但默认是16，不是懒加载，每个Segment对应一个小的哈希表，以此实现分段锁</li>
<li><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314195158551.png" alt="image-20220314195158551"></li>
</ul>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul>
<li>初始化链表last&#x3D;head&#x3D;new Node<E>(null);Dummy节点用来占位，item为null</li>
</ul>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314195540213.png" alt="image-20220314195540213"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h=head;</span><br><span class="line">Noed&lt;E&gt; first=h.next;</span><br><span class="line">h.next=h; <span class="comment">//出队是next指向自己 帮助GC</span></span><br><span class="line">head=first;</span><br><span class="line">E x=first.item;</span><br><span class="line">first.item=<span class="literal">null</span>; <span class="comment">//老二就成了dummy了 牛鼻</span></span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>



<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314200128763.png" alt="image-20220314200128763"></p>
<ul>
<li>高明之处：用了两把锁和dummy节点<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者）执行</li>
<li>用两把锁，同一时刻可以允许两个线程同时（一个生产者一个消费者）执行<ul>
<li>消费者之间串行</li>
<li>生产者之间串行</li>
</ul>
</li>
<li>线程安全分析（同时存在生产者消费者）<ul>
<li>节点总数大于2，putlock保证的是last节点安全，takeLock保证head节点安全，两把锁保证入队和出队没有竞争</li>
<li>节点总数等于2,一个dummy节点，一个正常节点，两把锁锁两个对象，不会竞争</li>
<li>节点总数等于1，只有一个节点，相当于队列为空，这时候take会因为empty条件陷入阻塞，</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul>
<li>Linked支持有界，Array强制有界</li>
<li>Linked链表实现，Array数组实现</li>
<li>linked懒惰初始化，Array提前初始化Node数组</li>
<li>Linked每次入队生成新的Node，Array的Node提前创建好</li>
<li>Linked两把锁，Array一把锁</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><ul>
<li>两把【锁】，同一时刻允许两个线程（生产者和消费者）执行</li>
<li>dummy节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li>
<li>这个【锁】使用了CAS实现，所以说这个【锁】不是真的锁</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteSet里面也是套了一个CopyOnWriteArrayList，写入时是addIfAbsent</p>
<p>底层实现都采用【写入时拷贝】的思想，增删查改操作会将底层数组拷贝一份，更改操作在新数组上进行，这时不影响其他线程的并发读，读写分离，读读并发，读写并发，只有写写互斥</p>
<p> 也是弱一致性，比如Get后其他元素在中间做操作，其实Get还是原来的东西，比如获得迭代器，实在旧数组上进行迭代，但不要觉得弱一致性不好，数据库的MVCC就是弱一致性的表现，高并发和一致性是矛盾的，需要权衡</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20220314205504786.png" alt="image-20220314205504786"></p>
<p>多线程访问共享变量时如果不考虑锁、CAS就会产生线程安全问题，但如果给每个线程都建立一个该变量的副本，每个线程都操作自己的变量就没问题了。</p>
<p>每一个Thread维护了一个ThreadLocalMap，可以通过ThreadLocal找到对应的线程本地变量</p>
<h5 id="ThreadLocalMap中的Entry是弱引用"><a href="#ThreadLocalMap中的Entry是弱引用" class="headerlink" title="ThreadLocalMap中的Entry是弱引用"></a>ThreadLocalMap中的Entry是弱引用</h5><p>①强引用：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p>
<p>②软引用：简言之，如果一个对象具有弱引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p>
<p>③弱引用（这里讨论ThreadLocalMap中的Entry类的重点）：如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收期回收掉，JVM会将这个引用加入到与之关联的引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用的对象呗回收掉之后，再调用get方法就会返回null</p>
<p>④虚引用：虚引用是所有引用中最弱的一种引用，其存在就是为了将关联虚引用的对象在被GC掉之后收到一个通知。（不能通过get方法获得其指向的对象）</p>
<p>ThreadLocalMap中的Key是ThreadLocal的弱引用，gc后就会被回收，但是value依然存在，就可能导致内存泄漏，因此使用完毕后需要调用remove方法避免内存泄漏，线程结束value会被销毁，但线程池往往TM不结束线程</p>
<h5 id="有什么必要用thread-local"><a href="#有什么必要用thread-local" class="headerlink" title="有什么必要用thread local"></a>有什么必要用thread local</h5><p>一个web程序 多线程模型 想要给每个线程创建一个全局变量 user 该如何做 </p>
<p>很自然地想到 创建一个静态的map 他在方法区里 任意一个线程都可以访问到  map的Key是thread Value是user</p>
<p>如果存多个变量怎么办 创建多个map </p>
<p>但是非常的不方便 </p>
<p>所以为每个线程加一个map 你通过threadlocal这个key 就能找到对应的value</p>
<p>一种是  WrapperClass.userMap(thread)</p>
<p>一种是   thread.threadlocalmap(threadlocal)</p>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><ul>
<li><p>强内存模型：内存模型易于理解易于编程，为程序员提供足够强的内存可见性保证</p>
</li>
<li><p>弱内存模型：内存模型束缚尽可能少，尽可能多地进行优化来提升性能，但影响程序员的理解性</p>
</li>
</ul>
<p>为了在俩者之间取得平衡，JMM 通过Happens-before作为其核心概念</p>
<p>Happens-before 是 JMM 的灵魂，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。</p>
<p>JMM 其实是在遵循一个基本原则，即只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。</p>
<p>as-if-serial 语义：不管怎么重排序，单线程环境下程序的执行结果不能被改变。</p>
<p>本质上来说 Happens-before 关系和 as-if-serial 语义是一回事，<strong>都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。只不过后者只能作用在单线程，而前者可以作用在正确同步的多线程环境下：</p>
<ul>
<li>as-if-serial 语义保证单线程内程序的执行结果不被改变，Happens-before 关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。Happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 Happens-before 指定的顺序来执行的。</li>
</ul>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>解决C10K问题，同时1万个并发咋办？创建10K个进程？10K个线程？线程池？都扛不住，使用一个进程来维护多个Sokcet，称为IO多路复用。</p>
<p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p>
<h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>一个进程管理N个Socket，对应N个文件描述符，内核态会扫一遍描述符，如果S检查到有事件产生设计标记位（bitmap(select实现）或者链表（poll实现机制），再拷贝到用户态，用户态下该进程再扫一遍描述符，扫到了再处理，时间复杂度O（n)</p>
<blockquote>
<p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
</blockquote>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>socket是有序的，用红黑树来存取，log(n)</p>
<blockquote>
<p><em>第一点</em>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 <code>O(logn)</code>，通过对这棵黑红树进行操作，这样就不需要像 select&#x2F;poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p><em>第二点</em>， epoll 使用事件驱动的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p>网上文章不少说，<code>epoll_wait</code> 返回时，对于就绪的事件，epoll使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p>
<p>这是错的！看过 epoll 内核源码的都知道，<strong>压根就没有使用共享内存这个玩意</strong>。</p>
<p><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/v2-c7246e74cc64c786360ae12e266e0362_r.jpg" alt="img"></p>
<p>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</p>
<p>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</p>
</blockquote>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/02/04/JAVA-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="next" title="JAVA 内存模型">
                <i class="fa fa-chevron-left"></i> JAVA 内存模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(NJU%20JYYOS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0)/" rel="prev" title="操作系统 (NJU JYYOS课程笔记)">
                操作系统 (NJU JYYOS课程笔记) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">2.0.2.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">2.0.3.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.4.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Interrupt"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.4.2.</span> <span class="nav-text">守护线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">2.0.5.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">2.0.6.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.0.7.</span> <span class="nav-text">设计原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized"><span class="nav-number">3.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="nav-number">3.0.1.</span> <span class="nav-text">线程安全类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BC%9A%E5%BC%95%E5%8F%91%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">3.0.2.</span> <span class="nav-text">怎么样会引发线程不安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4-%EF%BC%8C%E9%94%81%E5%88%B0%E5%BA%95%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">3.0.3.</span> <span class="nav-text">对象头 ，锁到底在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monitor%EF%BC%88%E7%9B%91%E8%A7%86%E5%99%A8-x2F-%E7%AE%A1%E7%A8%8B%EF%BC%89"><span class="nav-number">3.0.4.</span> <span class="nav-text">Monitor（监视器&#x2F;管程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.0.5.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89%EF%BC%9A%E9%94%81%E8%87%AA%E6%97%8B"><span class="nav-number">3.0.6.</span> <span class="nav-text">重量级锁竞争：锁自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">3.0.7.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-%E5%92%8C-notify"><span class="nav-number">3.0.8.</span> <span class="nav-text">wait() 和 notify()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.9.</span> <span class="nav-text">sleep 和 wait 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.0.10.</span> <span class="nav-text">同步模式： 保护性暂停模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#park%E5%92%8CNotify%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.11.</span> <span class="nav-text">park和Notify的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.0.12.</span> <span class="nav-text">线程之间的状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E9%94%81"><span class="nav-number">3.0.13.</span> <span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF"><span class="nav-number">3.0.14.</span> <span class="nav-text">饥饿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.0.15.</span> <span class="nav-text">死锁的四个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">3.0.16.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="nav-number">3.0.17.</span> <span class="nav-text">知识回顾</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">4.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">4.0.1.</span> <span class="nav-text">指令重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="nav-number">4.0.2.</span> <span class="nav-text">volatile原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dcl-double-check-lock%E9%97%AE%E9%A2%98"><span class="nav-number">4.0.3.</span> <span class="nav-text">dcl double check lock问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">4.0.4.</span> <span class="nav-text">单例模式问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.0.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91-%E4%B9%90%E8%A7%82%E9%94%81%E6%96%B9%E5%BC%8F%EF%BC%88%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">无锁并发 乐观锁方式（实现非阻塞并发访问）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.0.1.</span> <span class="nav-text">CAS工作方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-1"><span class="nav-number">5.0.2.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98%E4%B8%8D%E9%AB%98%EF%BC%9F"><span class="nav-number">5.0.3.</span> <span class="nav-text">无锁效率高不高？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E7%89%B9%E7%82%B9"><span class="nav-number">5.0.4.</span> <span class="nav-text">CAS特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">5.0.5.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">5.0.6.</span> <span class="nav-text">原子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LongAdder-%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">5.0.7.</span> <span class="nav-text">LongAdder 原子累加器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe%E7%B1%BB"><span class="nav-number">5.0.8.</span> <span class="nav-text">Unsafe类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">5.0.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.</span> <span class="nav-text">不可变对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.1.</span> <span class="nav-text">final变量原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.2.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.2.1.</span> <span class="nav-text">为什么要用线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">线程池状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">5.2.3.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invokeAll%E5%92%8CinvokeAny"><span class="nav-number">5.2.4.</span> <span class="nav-text">invokeAll和invokeAny</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.2.5.</span> <span class="nav-text">结束线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82"><span class="nav-number">5.2.6.</span> <span class="nav-text">创建多少个线程合适</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.2.7.</span> <span class="nav-text">tomcat线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-x2F-Join"><span class="nav-number">5.2.8.</span> <span class="nav-text">Fork&#x2F;Join</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC"><span class="nav-number">6.</span> <span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-number">6.0.1.</span> <span class="nav-text">AQS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="nav-number">6.0.2.</span> <span class="nav-text">ReentrantLock原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">6.1.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">6.1.1.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.2.</span> <span class="nav-text">读写锁实现缓存、缓存更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.3.</span> <span class="nav-text">读写锁设计原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stampedLock"><span class="nav-number">6.1.4.</span> <span class="nav-text">stampedLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">6.1.5.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountdownLatch"><span class="nav-number">6.1.6.</span> <span class="nav-text">CountdownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CycliBarrier"><span class="nav-number">6.1.7.</span> <span class="nav-text">CycliBarrier</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="nav-number">7.</span> <span class="nav-text">线程安全集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">7.0.1.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK7"><span class="nav-number">7.0.1.0.1.</span> <span class="nav-text">JDK7</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">7.0.2.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">7.0.3.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">7.0.4.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">7.0.5.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">7.0.6.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadLocalMap%E4%B8%AD%E7%9A%84Entry%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">7.0.6.0.1.</span> <span class="nav-text">ThreadLocalMap中的Entry是弱引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E5%BF%85%E8%A6%81%E7%94%A8thread-local"><span class="nav-number">7.0.6.0.2.</span> <span class="nav-text">有什么必要用thread local</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Happens-Before"><span class="nav-number">7.1.</span> <span class="nav-text">Happens Before</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-x2F-poll"><span class="nav-number">7.2.1.</span> <span class="nav-text">select&#x2F;poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">7.2.2.</span> <span class="nav-text">epoll</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pan Li</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">19.1k</span>
  
</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
